{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 2c6d894bbbca63ca957f","webpack:///./src/main.js","webpack:///./src/statement.js","webpack:///./src/table.js","webpack:///./~/markdown-table/index.js"],"names":["Statement","table","require","statement","symbols","extractSymbols","error","checkWellFormed","Error","variables","extractvariables","symbolsRPN","convertToRPN","tree","RPNToTree","values","evalReady","performSubstitution","outStack","operands","symbol","push","pop","evaluate","closingParen","outQueue","opStack","match","length","compareOperators","apply","reverse","isOperand","opening","closing","prev","next","isOperator","wasOperator","i","undefined","includes","accepted","split","idx","cond","bicond","extracted","indexOf","slice","charAt","op1","op2","operators","prepared","operator","right","size","mdTable","getValues","n","t","concat","getCases","numVars","numRows","rows","row","j","statementToTable","s","tableToMarkdown","header","replace","align","makeTruthTable","type","format","toLowerCase"],"mappings":"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","file":"Tombstone.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Tombstone\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Tombstone\"] = factory();\n\telse\n\t\troot[\"Tombstone\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 2c6d894bbbca63ca957f","import Statement from 'statement'\n\nexport {Statement}\n\n\n\n// WEBPACK FOOTER //\n// ./src/main.js","var table = require('./table')\n\nclass Statement {\n    constructor(statement) {\n        this.symbols = extractSymbols(statement)\n        let error = checkWellFormed(this.symbols)\n        if (error) {\n            throw new Error(error)\n        }\n        this.statement = statement\n        this.variables = extractvariables(this.statement)\n        this.symbolsRPN = convertToRPN(this.symbols)\n        this.tree = RPNToTree(this.symbolsRPN)\n    }\n\n    evaluate(values) {\n        const evalReady = performSubstitution(this.symbolsRPN, values)\n        let outStack = []\n        let operands = []\n\n        for ( let symbol of evalReady ) {\n            if (typeof symbol === 'boolean') {\n                outStack.push(symbol)\n            } else {\n                operands.push(outStack.pop())\n                if (symbol !== '~') {\n                    operands.push(outStack.pop())\n                }\n                outStack.push(evaluate(symbol, operands))\n                operands = []\n            }\n        }\n\n        return outStack[0]\n    }\n\n    variables() {\n        return this.variables\n    }\n\n    symbols() {\n        return this.symbols\n    }\n\n    table() {\n        return table(this, 'Json')\n    }\n}\n\n/**\n * Uses the Shunting-Yard algorithm to convert a propositional logic statement\n * to Reverse Polish notation (RPN).\n *\n * @example\n * // [ 'P', 'Q', '<->', 'R', 'Q', '|', '&', 'S', '->' ]\n * convertToRPN('(P <-> Q) & (R | Q) -> S')\n *\n * @param   {String} statement - The statement to be converted.\n *\n * @returns {Array} - The statement in RPN.\n */\nfunction convertToRPN(symbols) {\n    let closingParen = false\n    let outQueue = []\n    let opStack = []\n\n    for ( let symbol of symbols ) {\n        if (symbol.match(/^[a-z]{1}$/i)) {\n            outQueue.push(symbol)\n        } else if (symbol === ')') {\n            closingParen = false\n            while (!closingParen && opStack[opStack.length - 1] !== '(') {\n                outQueue.push(opStack.pop())\n                closingParen = opStack[opStack.length - 1] === '('\n            }\n            opStack.pop()\n        } else {\n            while (compareOperators(symbol, opStack[opStack.length - 1])) {\n                outQueue.push(opStack.pop())\n            }\n            opStack.push(symbol)\n        }\n    }\n\n    outQueue.push.apply(outQueue, opStack.reverse())\n    return outQueue\n}\n\n/**\n * Verify that the symbols array is valid.\n *\n * @param  {Array} symbols - The list of symbols to be checked.\n *\n * @return {String|null} - A message if an error is found and null otherwise.\n */\nfunction checkWellFormed(symbols) {\n    let isOperand = /^[a-z()]{1}$/i\n    let opening = 0\n    let closing = 0\n    let symbol = null\n    let prev = null\n    let next = null\n    let isOperator = false\n    let wasOperator = false\n    let error = null\n\n    if (symbols.length === 0) {\n        return 'no symbols!'\n    }\n\n    for (let i = 0; i < symbols.length; ++i) {\n        symbol = symbols[i]\n        next = symbols[i + 1] === undefined ? '' : symbols[i + 1]\n        prev = symbols[i - 1] === undefined ? '' : symbols[i - 1]\n        isOperator = ['~', '&', '||', '->', '<->'].includes(symbol)\n        if (!isOperator && !symbol.match(isOperand)) {\n            error = 'unknown symbol!'\n        }\n        if (symbol === '(') {\n            opening += 1\n        } else if (symbol === ')') {\n            closing += 1\n        } else if (isOperator && wasOperator && symbol !== '~') {\n            error = 'double operators!'\n        } else if (isOperator && symbol !== '~') {\n            if (!prev.match(isOperand) || (next !== '~' && !next.match(isOperand))) {\n                error = 'missing operand!'\n            }\n        } else if (symbol === '~') {\n            if (!next.match(isOperand)) {\n                error = 'missing operand!'\n            }\n        }\n        wasOperator = isOperator\n    }\n\n    if (opening !== closing) {\n        error = 'unbalanced parentheses!'\n    } else if (symbols.length === (opening + closing)) {\n        error = 'no symbols!'\n    }\n    return error\n}\n\n/**\n * Extract all symbols from statement.\n *\n * @example\n * // [ 'P', '&', '~', 'Q' ]\n * extractSymbols('P & ~Q')\n *\n * @example\n * // [ '(', 'P', '<->', 'Q', ')', '&', '(', 'R', '|', 'Q', ')', '->', 'S' ]\n * extractSymbols('(P<-> Q) & (R|Q) ->S')\n *\n * @param   {String} statement - The statement to be parsed.\n *\n * @returns {Array} - An array containing each symbol.\n */\nfunction extractSymbols(statement) {\n    const accepted = ['(', ')', '->', '&', '||', '~', '<->']\n    const symbols = statement.split(' ')\n    let idx = 0\n    let cond = null\n    let bicond = null\n    let extracted = []\n\n    for ( let symbol of symbols ) {\n        if (!symbol.match(/^[a-z]+$/i) && accepted.indexOf(symbol) < 0) {\n            idx = 0\n            while (idx < symbol.length) {\n                cond = symbol.slice(idx, idx + 2)\n                bicond = symbol.slice(idx, idx + 3)\n                if (bicond === '<->') {\n                    extracted.push(bicond)\n                    idx += 3\n                } else if (cond === '->' || cond === '||') {\n                    extracted.push(cond)\n                    idx += 2\n                } else {\n                    extracted.push(symbol.charAt(idx))\n                    idx += 1\n                }\n            }\n        } else {\n            extracted.push(symbol)\n        }\n    }\n\n    return extracted\n}\n\n/**\n * Extract the variables from a given statement.\n *\n * @param   {String} statement - The statement to be considered.\n *\n * @returns {Array} - All of the variables in the given statement.\n */\nfunction extractvariables(statement) {\n    const symbols = extractSymbols(statement)\n    let variables = []\n\n    for ( let symbol of symbols ) {\n        if (symbol.match(/^[a-z]+$/i)) {\n            variables.push(symbol)\n        }\n    }\n\n    return variables\n}\n\n/**\n * Compare the precedence of two operators.\n *\n * @param   {String} op1 - The first operator.\n * @param   {String} op2 - The second operator.\n *\n * @returns {Boolean} - true if op1 has lower precedence than op2 and false\n *  otherwise.\n */\nfunction compareOperators(op1, op2) {\n    const operators = ['~', '&', '||', '->', '<->']\n    if (op2 === undefined || op2 === '(') {\n        return false\n    }\n    return operators.indexOf(op1) > operators.indexOf(op2)\n}\n\n/**\n * Substitute values for symbols where possible.\n *\n * @example\n * // [ 'true', '&', '~', 'false' ]\n * performSubstitution(['P', '&', '~', 'Q'], {'P': true, 'Q': false})\n *\n * @param   {Array} symbols - The symbols to be considered.\n * @param   {Object} values - An object mapping symbols to their intended\n *  values.\n *\n * @returns {Array} - An array with symbols replaced by their values.\n */\nfunction performSubstitution(symbols, values) {\n    let prepared = []\n\n    for ( let symbol of symbols ) {\n        if (['(', ')', '->', '&', '||', '<->', '~'].includes(symbol)) {\n            prepared.push(symbol)\n        } else {\n            prepared.push(values[symbol])\n        }\n    }\n\n    return prepared\n}\n\n/**\n * Evaluate the given operator with its operand(s).\n *\n * @param   {String} operator - The operator to be used.\n * @param   {Array} operands - The operands to be used.\n *\n * @returns {Boolean} - The result of the evaluation.\n */\nfunction evaluate(operator, operands) {\n    switch (operator) {\n    case '~':\n        return !operands[0]\n    case '&':\n        return operands[0] && operands[1]\n    case '||':\n        return operands[0] || operands[1]\n    case '->':\n        return !operands[1] || operands[0]\n    case '<->':\n        return operands[0] === operands[1]\n    }\n}\n\nfunction RPNToTree(symbols) {\n    let outStack = []\n    let right = null\n    let size = 0\n\n    for ( let symbol of symbols ) {\n        if (symbol.match(/^[a-z]{1}$/i)) {\n            outStack.push({\n                'name': symbol\n            })\n        } else {\n            right = outStack.pop()\n            if (symbol === '~') {\n                outStack.push({\n                    'name': symbol,\n                    'children': [right]\n                })\n            } else {\n                outStack.push({\n                    'name': symbol,\n                    'children': [right, outStack.pop()]\n                })\n            }\n        }\n        size += 1\n    }\n\n    return {\n        'tree': outStack,\n        'size': size\n    }\n}\n\nexport default Statement\n\n\n\n// WEBPACK FOOTER //\n// ./src/statement.js","var mdTable = require('markdown-table')\n\n/**\n * Get all boolean input values for n variables.\n *\n * @example\n * // [ [ true, true ], [ true, false ], [ false, true ], [ false, false ] ]\n * getValues(2, [])\n *\n * @param   {Number} n - The number of variables.\n * @param   {Array} t - The array to be recursively filled.\n *\n * @returns {Array} All possible input values.\n */\nfunction getValues(n, t) {\n    if (t.length === n) {\n        return [t]\n    } else {\n        return getValues(n, t.concat(true)).concat(getValues(n, t.concat(false)))\n    }\n}\n\n/**\n * Get all boolean values for each variable.\n *\n * @example\n * // [ { P: true }, { P: false } ]\n * getCases (['P'])\n *\n * @param   {Array} variables - All variables in a given statement.\n *\n * @returns {Array} - An array of objects mapping variables to their possible\n *  values.\n */\nfunction getCases(variables) {\n    var numVars = variables.length\n    var values = getValues(numVars, [])\n    var numRows = values.length\n    var rows = []\n    var row = {}\n\n    for (var i = 0; i < numRows; ++i) {\n        row = {}\n        for (var j = 0; j < numVars; ++j) {\n            row[variables[j]] = values[i][j]\n        }\n        rows.push(row)\n    }\n\n    return rows\n}\n\n/**\n * Convert a statement into an object representing the structure of a table.\n *\n * @param   {Object} s - The statement to be converted.\n *\n * @returns {Object} - The table representation.\n */\nfunction statementToTable(s) {\n    var table = {}\n\n    table['statement'] = s.statement\n    table['variables'] = s.variables\n    table['rows'] = getCases(table['variables'])\n    for (var i = 0; i < table['rows'].length; ++i) {\n        table['rows'][i]['eval'] = s.evaluate(table['rows'][i])\n    }\n\n    return table\n}\n\n/**\n * Create a Markdown-formatted truth table.\n *\n * @param   {Object} table - The table to be converted to Markdown.\n *\n * @returns {String} The Markdown-formatted table.\n */\nfunction tableToMarkdown(table) {\n    var rows = []\n    var row = []\n    var header = table['variables'].slice()\n\n    header.push(table['statement'].replace(/\\|/g, '&#124;'))\n    rows.push(header)\n    for (var i = 0; i < table['rows'].length; ++i) {\n        row = []\n        for (var j = 0; j < table['variables'].length; ++j) {\n            row.push(table['rows'][i][table['variables'][j]])\n        }\n        row.push(table['rows'][i]['eval'])\n        rows.push(row)\n    }\n\n    return mdTable(rows, {\n        align: 'c'\n    })\n}\n\n/**\n * Create a truth table from a given statement.\n *\n * @param   {String} s - The statement.\n * @param   {String} type - The table format.\n *\n * @returns {String} - The formatted table.\n */\nfunction makeTruthTable(s, type) {\n    var table = statementToTable(s)\n    var format = type.toLowerCase()\n\n    // TODO: Add support for other formats\n    switch (format) {\n    case 'markdown':\n        return tableToMarkdown(table)\n    case 'json':\n        return table\n    }\n}\n\n// module.exports.truthTable = makeTruthTable\nexport default makeTruthTable\n\n\n\n// WEBPACK FOOTER //\n// ./src/table.js","'use strict';\n\n/* Expose. */\nmodule.exports = markdownTable;\n\n/* Expressions. */\nvar EXPRESSION_DOT = /\\./;\nvar EXPRESSION_LAST_DOT = /\\.[^.]*$/;\n\n/* Allowed alignment values. */\nvar LEFT = 'l';\nvar RIGHT = 'r';\nvar CENTER = 'c';\nvar DOT = '.';\nvar NULL = '';\n\nvar ALLIGNMENT = [LEFT, RIGHT, CENTER, DOT, NULL];\nvar MIN_CELL_SIZE = 3;\n\n/* Characters. */\nvar COLON = ':';\nvar DASH = '-';\nvar PIPE = '|';\nvar SPACE = ' ';\nvar NEW_LINE = '\\n';\n\n/* Create a table from a matrix of strings. */\nfunction markdownTable(table, options) {\n  var settings = options || {};\n  var delimiter = settings.delimiter;\n  var start = settings.start;\n  var end = settings.end;\n  var alignment = settings.align;\n  var calculateStringLength = settings.stringLength || lengthNoop;\n  var cellCount = 0;\n  var rowIndex = -1;\n  var rowLength = table.length;\n  var sizes = [];\n  var align;\n  var rule;\n  var rows;\n  var row;\n  var cells;\n  var index;\n  var position;\n  var size;\n  var value;\n  var spacing;\n  var before;\n  var after;\n\n  alignment = alignment ? alignment.concat() : [];\n\n  if (delimiter === null || delimiter === undefined) {\n    delimiter = SPACE + PIPE + SPACE;\n  }\n\n  if (start === null || start === undefined) {\n    start = PIPE + SPACE;\n  }\n\n  if (end === null || end === undefined) {\n    end = SPACE + PIPE;\n  }\n\n  while (++rowIndex < rowLength) {\n    row = table[rowIndex];\n\n    index = -1;\n\n    if (row.length > cellCount) {\n      cellCount = row.length;\n    }\n\n    while (++index < cellCount) {\n      position = row[index] ? dotindex(row[index]) : null;\n\n      if (!sizes[index]) {\n        sizes[index] = MIN_CELL_SIZE;\n      }\n\n      if (position > sizes[index]) {\n        sizes[index] = position;\n      }\n    }\n  }\n\n  if (typeof alignment === 'string') {\n    alignment = pad(cellCount, alignment).split('');\n  }\n\n  /* Make sure only valid alignments are used. */\n  index = -1;\n\n  while (++index < cellCount) {\n    align = alignment[index];\n\n    if (typeof align === 'string') {\n      align = align.charAt(0).toLowerCase();\n    }\n\n    if (ALLIGNMENT.indexOf(align) === -1) {\n      align = NULL;\n    }\n\n    alignment[index] = align;\n  }\n\n  rowIndex = -1;\n  rows = [];\n\n  while (++rowIndex < rowLength) {\n    row = table[rowIndex];\n\n    index = -1;\n    cells = [];\n\n    while (++index < cellCount) {\n      value = row[index];\n\n      value = stringify(value);\n\n      if (alignment[index] === DOT) {\n        position = dotindex(value);\n\n        size = sizes[index] +\n          (EXPRESSION_DOT.test(value) ? 0 : 1) -\n          (calculateStringLength(value) - position);\n\n        cells[index] = value + pad(size - 1);\n      } else {\n        cells[index] = value;\n      }\n    }\n\n    rows[rowIndex] = cells;\n  }\n\n  sizes = [];\n  rowIndex = -1;\n\n  while (++rowIndex < rowLength) {\n    cells = rows[rowIndex];\n\n    index = -1;\n\n    while (++index < cellCount) {\n      value = cells[index];\n\n      if (!sizes[index]) {\n        sizes[index] = MIN_CELL_SIZE;\n      }\n\n      size = calculateStringLength(value);\n\n      if (size > sizes[index]) {\n        sizes[index] = size;\n      }\n    }\n  }\n\n  rowIndex = -1;\n\n  while (++rowIndex < rowLength) {\n    cells = rows[rowIndex];\n\n    index = -1;\n\n    if (settings.pad !== false) {\n      while (++index < cellCount) {\n        value = cells[index];\n\n        position = sizes[index] - (calculateStringLength(value) || 0);\n        spacing = pad(position);\n\n        if (alignment[index] === RIGHT || alignment[index] === DOT) {\n          value = spacing + value;\n        } else if (alignment[index] === CENTER) {\n          position /= 2;\n\n          if (position % 1 === 0) {\n            before = position;\n            after = position;\n          } else {\n            before = position + 0.5;\n            after = position - 0.5;\n          }\n\n          value = pad(before) + value + pad(after);\n        } else {\n          value += spacing;\n        }\n\n        cells[index] = value;\n      }\n    }\n\n    rows[rowIndex] = cells.join(delimiter);\n  }\n\n  if (settings.rule !== false) {\n    index = -1;\n    rule = [];\n\n    while (++index < cellCount) {\n      /* When `pad` is false, make the rule the same size as the first row. */\n      if (settings.pad === false) {\n        value = table[0][index];\n        spacing = calculateStringLength(stringify(value));\n        spacing = spacing > MIN_CELL_SIZE ? spacing : MIN_CELL_SIZE;\n      } else {\n        spacing = sizes[index];\n      }\n\n      align = alignment[index];\n\n      /* When `align` is left, don't add colons. */\n      value = align === RIGHT || align === NULL ? DASH : COLON;\n      value += pad(spacing - 2, DASH);\n      value += align !== LEFT && align !== NULL ? COLON : DASH;\n\n      rule[index] = value;\n    }\n\n    rows.splice(1, 0, rule.join(delimiter));\n  }\n\n  return start + rows.join(end + NEW_LINE + start) + end;\n}\n\nfunction stringify(value) {\n  return (value === null || value === undefined) ? '' : String(value);\n}\n\n/* Get the length of `value`. */\nfunction lengthNoop(value) {\n  return String(value).length;\n}\n\n/* Get a string consisting of `length` `character`s. */\nfunction pad(length, character) {\n  return Array(length + 1).join(character || SPACE);\n}\n\n/* Get the position of the last dot in `value`. */\nfunction dotindex(value) {\n  var match = EXPRESSION_LAST_DOT.exec(value);\n\n  return match ? match.index + 1 : value.length;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/markdown-table/index.js\n// module id = 4\n// module chunks = 0"],"sourceRoot":""}